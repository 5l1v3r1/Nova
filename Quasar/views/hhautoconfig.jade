//- ============================================================================
//-  Copyright   : DataSoft Corporation 2011-2013
//-  Nova is free software: you can redistribute it and/or modify
//-   it under the terms of the GNU General Public License as published by
//-   the Free Software Foundation, either version 3 of the License, or
//-   (at your option) any later version.
//-
//-   Nova is distributed in the hope that it will be useful,
//-   but WITHOUT ANY WARRANTY; without even the implied warranty of
//-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//-   GNU General Public License for more details.
//-
//-   You should have received a copy of the GNU General Public License
//-   along with Nova.  If not, see <http://www.gnu.org/licenses/>.
//- ============================================================================

extends layout

block headerAdditions
  script(src="scripts/spin.js")
  script
    var Interfaces = "#{INTERFACES}";
    var InterfaceAliases = "#{interfaceAliases}";
   
    var interfaceList = Interfaces.split(',');
    var interfaceAliasList = InterfaceAliases.split(',');
    
    function viewModelApp() {
        var self = this;
        self.isNewHaystack = ko.observable(true);
        self.newHaystackName = ko.observable("");
        self.oldHaystackName = ko.observable("");
        self.groupName = ko.computed(function() {
           if (self.isNewHaystack()) {
            return self.newHaystackName();
           } else {
            return self.oldHaystackName();
           }
        }, self);

        self.subnetsToScan = ko.observableArray();
        self.interfaceSubnets = ko.observableArray();

        self.interfaceList = interfaceList;

        self.removeSubnet = function(subnet) {
            self.subnetsToScan.remove(subnet);
        }
        
        self.addSubnet = function(subnet) {
            if (!isSubnetScanned(subnet.subnet)) {
                self.subnetsToScan.push(subnet);
            }
        }
    };

    var viewModel = new viewModelApp();

    function validateAndAdd(id)
    {
      var toValidate = document.getElementById(id).value;
    
      var regex = new RegExp("^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\/[1-3]?[0-9]$");
    
      document.getElementById("errorLabel").style.color = 'red';
      if((toValidate[toValidate.length - 2] >= 3 && toValidate[toValidate.length - 1] > 2)
        || (toValidate[toValidate.length - 3] != '/' && toValidate[toValidate.length - 2] != '/'))
      {
        document.getElementById("errorLabel").innerHTML = "Invalid subnet bit value (e.g. 33 or higher)";
        return;
      }
    
      if(isSubnetScanned(toValidate))
      {
        document.getElementById("errorLabel").innerHTML = "That subnet is already in the subnets list";
        return;
      }
    
      if(regex.test(toValidate))
      {
        document.getElementById("errorLabel").style.color = 'green';
        document.getElementById("errorLabel").innerHTML = "Valid subnet found!";
        viewModel.subnetsToScan.push({subnet: toValidate});
        document.getElementById(id).value = '';
      }
      else
      {
        document.getElementById("errorLabel").innerHTML = "That is not a valid subnet.";
        return;
      }
    }
    
    function isSubnetScanned(test)
    {
      for (var i in viewModel.subnetsToScan()) {
        if (test == viewModel.subnetsToScan()[i].subnet) {
            return true;
        }
      }
      return false;
    }
    
    function RunScan()
    {
      if(GetNumNodes() == -1)
      {
        alert('There is a problem with your value for number of nodes!');
        return;
      }
      
      if(GetHaystackName() == '#')
      {
        alert('No special characters in group name! Alphanumeric only.');
        return;
      }
      
      if(viewModel.subnetsToScan().length != 0)
      { 
        disableBackground(document.getElementById('setup'));
        document.getElementById("startScan").value='Scanning...'; 
        document.getElementById("startScan").setAttribute('disabled', 'true');
        document.getElementById("lightbox").style.display='block';
        document.getElementById("setup").style.opacity='0.5';
        var opts = {
            lines: 17,
            length: 0,
            width: 4,
            radius: 27,
            corners: 0.6,
            rotate: 0,
            color: '#E8A02F',
            speed: 1,
            trail: 34,
            shadow: false,
            hwaccel: false,
            className: 'spinner',
            zIndex: 1003,
            top: 20,
            left: 'auto'
        };
        
        var spinner = new Spinner(opts).spin(document.getElementById('spinnerDiv'));
        document.getElementById('spinnerDiv').style.height = ((opts.radius * 2) + 30)+ 'px';
        var divWidth = document.getElementById('lightbox').scrollWidth;
        document.getElementById('appendText').style.width = divWidth + 'px';
        try 
        {
            var element = document.getElementById("nodeCountType");
            var count = element.options[element.selectedIndex].value;
            now.ShowAutoConfig(GetNodeInterface(), count, GetNumNodes(), GetSubnets(), GetHaystackName(), !viewModel.isNewHaystack(), autoscancb, routeToReview); 
        } 
        catch(err) 
        {
            alert("Action failed because unable to connect to server! Please try refreshing the page and trying again.");
            console.log("err was: " + err);
        }   
      } 
      else
      {
          alert("Must have at least one subnet for scanning");
          return false;
      }
    }

    function disableBackground(source)
    {
      var disableUs = source.childNodes;
      for(var i in disableUs)
      {
        if(typeof disableUs[i] == 'object' && disableUs[i].tagName != undefined)
        {
          disableUs[i].disabled = true;
          if(disableUs[i].hasChildNodes())
          {
            disableBackground(disableUs[i]);
          }
        }
      }
    }

    function enableBackground(source)
    {
      var enableUs = source.childNodes;
      for(var i in enableUs)
      {
        if(typeof enableUs[i] == 'object' && enableUs[i].tagName != undefined)
        {
          enableUs[i].disabled = false;
          if(enableUs[i].hasChildNodes())
          {
            enableBackground(enableUs[i]);
          }
        }
      }
    }

    function GetNumNodes()
    {
        var num;
        var element = document.getElementById("nodeCountType");
        var count = element.options[element.selectedIndex].value;
        if(count == "fixed") 
        {
          num = parseInt(document.getElementById("numNodes").value);
        } 
        else if(count == 'ratio')
        {
          num = parseFloat(document.getElementById("numNodes").value);
        }
        else if(count == 'range')
        {
          num = document.getElementById('numNodes').value;
          var regex = new RegExp('^([0-255]\\.){3}([0-255])\\-([0-255]\\.){3}([0-255])$');
          if(regex.test(num) == 'false')
          {
            num = -1;
          }
        }
        return num;
    }

    function GetNodeInterface()
    {
        return document.getElementById("nodeInterface").value;
    }
    
    function GetSubnets()
    {
        var returnString = "";
       
        for(var i in viewModel.subnetsToScan())
        {
            returnString += viewModel.subnetsToScan()[i].subnet;
            if(viewModel.subnetsToScan()[i + 1] != undefined)
            {
                returnString += ",";
            }
        }       
        
        return returnString;
    }

    function GetHaystackName()
    {
      var group = viewModel.groupName();
      if((new RegExp('^[a-zA-Z0-9 -_]+$')).test(group))
      {
        return group;
      } else {
        return '#';
      }
    }

    function autoscancb(text)
    {
        var p = document.createElement('p');
        p.value = text;
        p.innerHTML = text;
        document.getElementById('appendText').appendChild(p);
        document.getElementById('appendText').scrollTop = document.getElementById('appendText').scrollHeight;
    }
    
    function routeToReview(redirect)
    {
      window.location = redirect.toString();
    }

    function nodeNumberTypeChanged()
    {
       var element = document.getElementById("nodeCountType");
       var count = element.options[element.selectedIndex].value;
       if(count == "fixed") 
       {
         document.getElementById("numNodesLabel").innerHTML = "Number of Haystack Nodes to create";
         document.getElementById('numNodes').value = '1';
         document.getElementById('numNodes').placeholder = ''; 
         document.getElementById('numNodes').style.width = '170px';
       } 
       else if(count == 'ratio')
       {
         document.getElementById("numNodesLabel").innerHTML = "Ratio of nodes to create versus nodes found during scan";
         if (navigator.userAgent.indexOf("MSIE") == "-1") {
                document.getElementById('numNodes').type = 'number';
         }
         document.getElementById('numNodes').value = '1';
         document.getElementById('numNodes').placeholder = ''; 
         document.getElementById('numNodes').style.width = '170px';
       }
       else if(count == 'range')
       {
         document.getElementById("numNodesLabel").innerHTML = "Range of IP Addresses to fill";
         document.getElementById('numNodes').type = 'text';
         document.getElementById('numNodes').value = '';
         document.getElementById('numNodes').placeholder = '###.###.###.###-###.###.###.###'; 
         document.getElementById('numNodes').style.width = '205px';
       }
    }

    function cancelScan()
    {
      if(typeof now.CancelAutoScan == 'function')
      {
        now.CancelAutoScan(viewModel.groupName());
      }
      else
      {
        alert('*** DEBUG *** Error: now.CancelAutoScan not defined (should not see this)');
      }
    }

    function populateTable()
    {
      var checked = true;
      for(var i in interfaceList)
      {

        now.GetSubnetFromInterface(interfaceList[i], i, function(iface, subnet, index){
          if(subnet == '')
          {
            console.log('subnet string is empty; failed to get IP/netmask for interface ' + iface);
            return;
          }
        
          var text = subnet + ' (' + iface + " (Alias: " + interfaceAliasList[i] + '))';
          viewModel.interfaceSubnets.push({text: text, subnet: subnet});
        });
      } 
    }
   

    function init() {
      var initialized = false;
      now.ready(function(){
        if (!initialized)
        {
          initialized = true;
          ko.applyBindings(viewModel);
          populateTable();
        }
      });
    }

block content
  if(SCANERROR !== undefined)
    label(id="scanError", style="color: red;") #{SCANERROR}
    
  div#setup
    h1 Haystack Autoconfig
    br
    input(data-bind="checked: isNewHaystack", type='checkbox') 
    label(style='font-weight: bold;') New Haystack?
    br
    br
    label(id='nameLabel', style='font-weight: bold') Haystack Name
    br
    br
    input(data-bind="visible: isNewHaystack, value: newHaystackName, valueUpdate: 'afterkeydown'", type='text', placeholder='Required Field')
    select(data-bind="visible: !isNewHaystack(), value: oldHaystackName")
      - for(var i = 0; i < GROUPS.length; i++)
        - if(GROUPS[i] != '' && GROUPS[i] != undefined && GROUPS[i] != 'default')
          option #{GROUPS[i]}
    br
    hidden(id="length", value=INTERFACES.length)
    br    
    label#numNodesLabel(style='font-weight: bold') Number of Haystack Nodes to create
    br
    br
    select#nodeCountType(onchange="nodeNumberTypeChanged()")
      option(value="fixed", selected='selected') Fixed
      option(value="ratio") Ratio
      option(value="range") IP Range
    input(type="number", name="numNodes", id="numNodes", min="1", value="1")
    br
    br
    label(style='font-weight: bold') Interface to create nodes on
    br
    select#nodeInterface(data-bind="options: interfaceList")
    br
    br
    label(style="font-weight: bold;") Subnets to Scan
    br
    table
      tbody(data-bind="foreach: interfaceSubnets")
        tr
          td(data-bind="text: text", style="width: 200px")
          td
            button(data-bind="click: $root.addSubnet")
              img.buttonIcon(src="images/add.png")
              span.buttonSpan Add Subnet
    
    br
    label(style="font-weight: bold;") Additional Subnets to Scan
    br
    label(id="errorLabel", style="color:red;")  
    br
    input(type="text", style="width:200px", id="subnetToAdd", width="20", onkeydown="if(event.keyCode == 13){document.getElementById('addSubnet').click(); document.getElementById('subnetToAdd').value=''; event.returnValue=false; event.cancel=true; }", placeholder="xxx.xxx.xxx.xxx/##") 
    button(type="button", id="addSubnet", onclick="validateAndAdd(\"subnetToAdd\");")
     img.buttonIcon(src="images/add.png")
     span.buttonSpan Add Subnet
    br
    br
    table(id='showTable')
      thead
        tr
          th
            label Subnets to be scanned
      tbody(data-bind="foreach: subnetsToScan")
        tr
          td(data-bind="text: subnet", style="width: 200px")
          td
            button(data-bind="click: $root.removeSubnet")
              img.buttonIcon(src="images/delete.png")
              span.buttonSpan Delete
            
      
    br
    br
    button(id="startScan", onclick="RunScan()")
      img.buttonIcon(src="images/ok.png")
      span.buttonSpan Start Scan
    
  div(id="lightbox", class="white_content")
    label(style="font-size: 1.2em;") Scan Commencing...
    div(id='spinnerDiv', style="height: 30px; padding-botton: 30px;")
    div(id='appendText', style="height: 60%; width: auto; overflow-y: scroll; overflow-x: hidden")
    button(id='cancelscan', onclick='cancelScan()') Cancel Scan
    
