extends layout

block content
  div
    div#ProtocolPiChart(style="display: inline-block;float: left; margin: 10px;")
    div#tcpPiChart(style="display: inline-block; margin: 20px")
  br

  - for (var i = 0; i < 14; i++) {
    div(style="display: inline-block; margin: 8px")
      h3 #{String(featureNames).split(",")[i]}
      canvas(id = "chart#{i}", width="200px", height="200px", style="border: 1px solid black")
      p(id = "p#{i}")     
  -}
   
block headerAdditions
  script(type="text/javascript", src="scripts/NovaPiChart.js")
  script
    var data = new Array();
    var tcpChart = new NovaPiChart("tcpPiChart", 200);
    var protocolChart = new NovaPiChart("ProtocolPiChart", 200);
    
    // TODO: Don't send all the suspects, set up the plumbing to just request one
    function Init() {
        now.sendAllSuspects(OnNewSuspect)
    };

    function OnNewSuspect(suspect) {
        if (suspect.GetIpString == "#{suspectIp}" && suspect.GetInterface == "#{suspectInterface}") {
            console.log(suspect);
            data.push(suspect.GetFeatures);

            // TODO Don't hard code
            if (data.length > 100) {
                data.shift();
            }
            for (var i = 0; i < 14; i++) {
                drawGraph("chart" + i, data, i);
            }

            arr = new Array();
            arr.push({name: "SYN Packets", value: suspect.GetSynCount});
            arr.push({name: "RST Packets", value: suspect.GetRstCount});
            arr.push({name: "ACK Packets", value: suspect.GetAckCount});
            arr.push({name: "FIN Packets", value: suspect.GetFinCount});
            arr.push({name: "SYN ACK Packets", value: suspect.GetSynAckCount});
            arr = arr.sort(function(a,b) {return b.value - a.value});
            tcpChart.Render(arr);



            arr = new Array();
            arr.push({name: "TCP Packets", value: suspect.GetTcpPacketCount});
            arr.push({name: "UDP Packets", value: suspect.GetUdpPacketCount});
            arr.push({name: "ICMP Packets", value: suspect.GetIcmpPacketCount});
            arr.push({name: "Other", value: suspect.GetOtherPacketCount});
            arr = arr.sort(function(a,b) {return b.value - a.value});
            protocolChart.Render(arr);
        }

    };

    function drawGraph(canvas, data, index) {
        // TODO Don't hard code
        var m_width = 200;
        var m_height = 200;
        var border = 15;

        var width = m_width;
        var height = m_height - border*2;
        
        var c = document.getElementById(canvas);
        var p = document.getElementById("p" + index);
        var ctx = c.getContext("2d");
        ctx.clearRect (0, 0,m_width ,m_height);
       
        ctx.fillSTyle="#0000FF";

        var minY = data[0][index];
        var maxY = data[0][index];
        
        if (data.length == 1) {
            p.innerHTML = "<br> Current: " + data[data.length-1][index].toFixed(12);
            return;
        }


        var points = new Array();
        for (var i = 0; i < data.length; i++) {
            if (data[i][index] > maxY) {
                maxY = data[i][index];
            }

            if (data[i][index] < minY) {
                minY = data[i][index];
            }
        }

         
        for (var i = 0; i < data.length; i++) {
            var point = new Object();
            point.x = (width/(data.length - 1))*i;

            if (maxY == minY) {
                point.y = height/2;
            } else {
                point.y = border + height - ((1.0*data[i][index] - minY)/(maxY-minY) * height);
            }
            points.push(point);
        }
       
        // Draw grid lines
        ctx.strokeStyle="#A1A1A1";
        ctx.beginPath();
        ctx.moveTo(0, border);
        ctx.lineTo(width, border);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, height+border);
        ctx.lineTo(width, height+border);
        ctx.stroke();
        for (var i = 0; i < points.length; i++) {
            ctx.beginPath();
            ctx.moveTo(points[i].x,border);
            ctx.lineTo(points[i].x,height+border);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, points[i].y);
            ctx.lineTo(width, points[i].y);
            ctx.stroke();
        }
        
        ctx.fillStyle = "blue";
        ctx.font = "10px Arial";
        ctx.fillText(minY, 0, m_height); 
        ctx.fillText(maxY, 0, 10);
        

        
        ctx.strokeStyle="#FF0000";
        for (var i = 1; i < points.length; i++) {
            ctx.beginPath();
            ctx.moveTo(points[i-1].x, points[i-1].y);
            ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();
        }

        ctx.fillStyle="#0000FF";
        for (var i = 0; i < points.length; i++) {
            ctx.beginPath();
            ctx.arc(points[i].x,points[i].y,2,0,2*Math.PI);
            ctx.fill();
        }
        
        
        var trendString = "";
        // TODO Don't hard code
        var trendStringCutoff = 25;
        for (var i = points.length - 2; i >= 0; i--) {
            if (trendString.length > trendStringCutoff) {
                break;
            }

            if (points[i].y > points[i+1].y) {
                trendString = "+" + trendString;
            } else if (points[i].y < points[i+1].y) {
                trendString = "-" + trendString;
            } else {
                trendString = "=" + trendString;
            }
        }

        p.innerHTML = trendString;
        p.innerHTML += "<br> Current: " + data[data.length-1][index].toFixed(12);
        p.innerHTML += "<br> Delta: " + (data[data.length-1][index]- data[data.length-2][index]).toFixed(12);
    }



    require(["dojo/ready", "dojo/domReady!"], function(ready){
        ready(function() {
            now.ready(function() {
                now.OnNewSuspect = OnNewSuspect;
                Init();
            });
        });
    });


